import { expect } from "chai";
import { ethers } from "hardhat";
import { time } from "@nomicfoundation/hardhat-network-helpers";
import { SchrodingerPool, MockERC20, Attacker } from "../typechain-types";

describe("SchrÃ¶dinger Pool CTF", function () {
  async function deployFixture() {
    const [owner, honestLP, player] = await ethers.getSigners();

    const Mock = await ethers.getContractFactory("MockERC20");
    const t0 = (await Mock.deploy("Token 0", "TK0")) as MockERC20;
    const t1 = (await Mock.deploy("Token 1", "TK1")) as MockERC20;

    const Pool = await ethers.getContractFactory("SchrodingerPool");
    const pool = (await Pool.deploy(await t0.getAddress(), await t1.getAddress())) as SchrodingerPool;

    const initialLiq = ethers.parseEther("100000");
    await t0.mint(honestLP.address, initialLiq);
    await t1.mint(honestLP.address, initialLiq);

    await t0.connect(honestLP).approve(await pool.getAddress(), initialLiq);
    await t1.connect(honestLP).approve(await pool.getAddress(), initialLiq);
    await pool.connect(honestLP).mint(honestLP.address, initialLiq, initialLiq);

    return { pool, t0, t1, owner, honestLP, player };
  }

  it("Should allow the player to drain >70% using Attacker.sol", async function () {
    const { pool, t0, t1, player } = await deployFixture();

    await time.increase(13);

    const AttackerFactory = await ethers.getContractFactory("Attacker");
    const attacker = (await AttackerFactory.connect(player).deploy(await pool.getAddress())) as Attacker;

    const capital = ethers.parseEther("10");
    await t0.mint(await attacker.getAddress(), capital);
    await t1.mint(await attacker.getAddress(), capital);

    const initialPoolBalance: bigint = await t0.balanceOf(await pool.getAddress());
    console.log("Initial Pool Reserve:", ethers.formatEther(initialPoolBalance));

    // RUN EXPLOIT
    await attacker.connect(player).exploit();

    const finalPoolBalance: bigint = await t0.balanceOf(await pool.getAddress());
    const playerBalance: bigint = await t0.balanceOf(player.address);
    
    // FIX: Multiply by 100n (BigInt) instead of 100 (Number)
    const drainedPercent = (initialPoolBalance - finalPoolBalance) * 100n / initialPoolBalance;

    console.log("Final Pool Reserve:", ethers.formatEther(finalPoolBalance));
    console.log("Player Profit:", ethers.formatEther(playerBalance));
    console.log("Drained %:", drainedPercent.toString());

    expect(drainedPercent).to.be.greaterThan(70n);
  });
});